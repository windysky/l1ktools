package org.flowcyt.cfcs;
// CFCSParameter.java

/* ------------------------------------------------------------------------- *\
This software and documentation are provided 'as is' and Tree Star, Inc., its
contractors and partners specifically disclaim all other warranties, expressed
or implied, including but not limited to implied warranties of merchantability
and fitness for a particular purpose, or during any particular date range.

By using this software, you are agreeing to these limits of liability, and to
hold Tree Star harmless for any information, accurate or erroneous, that might
be generated by the program.  This software is intended for research use only.

Christopher Lane <cdl@best.classes> for Tree Star  1/14/2002      Copyright 2002
\* ------------------------------------------------------------------------- */

public final class CFCSParameter extends CFCSAbstractParameter
{
    private int fieldSize = Integer.MIN_VALUE;
    private int lambda = Integer.MIN_VALUE;

    private double power = Double.NaN;
    private double gain = Double.NaN;

    private static final double LOG10 = Math.log(10);

    /* friendly */
    static final int FIELDSIZE_FREE_FORMAT = 0;
    /* friendly */
    static final String FIELDSIZE_FREE_FORMAT_STRING = "*";

    // $PnB ---------------------------------------------------------------

    public final int getFieldSize()
    {
        if (isNotSet(fieldSize))
        {
            throw new CFCSError(CFCSUndefinedAttribute, "FieldSize");
        }

        return fieldSize;
    }

    public final void setFieldSize(final int fieldSize)
    {
        if (fieldSize != FIELDSIZE_FREE_FORMAT && fieldSize < 1)
        {
            throw new CFCSError(CFCSIllegalValue, fieldSize);
        }
        /* else */ this.fieldSize = fieldSize;
    }

    // $PnB (bis) ---------------------------------------------------------
    // CFCS API interface to FieldSize is integer but attribute isn't really

    public final String getFieldSizeString()
    {
        if (fieldSize == FIELDSIZE_FREE_FORMAT)
            return FIELDSIZE_FREE_FORMAT_STRING;

        return Integer.toString(getFieldSize());
    }
    public final void setFieldSizeString(final String fieldSize)
    {
        if (fieldSize.equalsIgnoreCase(FIELDSIZE_FREE_FORMAT_STRING))
        {
            setFieldSize(FIELDSIZE_FREE_FORMAT);
        }
        else
        {
            try
            {
                setFieldSize((new Integer(fieldSize)).intValue());
            }
            catch (NumberFormatException exception)
            {
                throw new CFCSError(CFCSBadValueConversion, exception);
            }
        }
    }
    // $PnG ---------------------------------------------------------------
    public final double getGain()
    {
        if (isNotSet(gain))
        {
            throw new CFCSError(CFCSUndefinedAttribute, "Gain");
        }

        return gain;
    }
    public final void setGain(final double gain)
    {
        this.gain = gain;
    }
    // $PnL ---------------------------------------------------------------
    public final int getExcitationWavelength()
    {
        if (isNotSet(lambda))
        {
            throw new CFCSError(CFCSUndefinedAttribute, "ExcitationWavelength");
        }

        return lambda;
    }

    public final void setExcitationWavelength(final int lambda)
    {
        if (lambda < 0)
        {
            throw new CFCSError(CFCSIllegalValue, lambda);
        }
        /* else */ this.lambda = lambda;
    }
    // $PnO ---------------------------------------------------------------
    public final double getLaserPower()
    {
        if (isNotSet(power))
        {
            throw new CFCSError(CFCSUndefinedAttribute, "LaserPower");
        }

        return power;
    }

    public final void setLaserPower(final double power)
    {
        if (power < 0)
        {
            throw new CFCSError(CFCSIllegalValue, power);
        }
        /* else */ this.power = power;
    }
    // $PnE ---------------------------------------------------------------

    // Overide $xnE version in CFCSAbstractParameter to add error checking.
    // Zero implies linear scaling, in which case the gain must be nonzero.

    public final void setLogDecades(final double decades)
    {
        if (decades == 0.0 && isSet(gain) && gain == 0.0)
        {
            throw new CFCSError(CFCSInconsistentValue, "Gain");
        }
        /* else */ super.setLogDecades(decades);
    }

    // --------------------------------------------------------------------
    // Using scaling information, converts the value corresponding to "scale"
    // into a channel number.  Out-of-range values are converted.

    public final int scaleToChannel(double scale)
    {
        final double channel;
	    final double decades = getLogDecades();

	    if (decades > 0.0)
        { // logarithmic
            double offset = getOffset();

            if (offset > 0.0)
                scale /= offset;

            channel = (Math.log(scale) / LOG10) * (getRange() / decades);
        }
        else
        { // linear
            channel = (isSet(gain) && gain > 0.0) ? scale * gain : scale;
        }

        return Math.round((float) channel);
    }

    // --------------------------------------------------------------------
    // Using scaling information, converts a channel number into a scaled
    // value.  Out-of-range values are converted.

    public final double channelToScale(final int channel)
    {
        final double decades = getLogDecades();

        if (decades > 0.0)
        { // logarithmic
            double scale = Math.pow(10.0, (channel * decades / getRange()));

            double offset = getOffset();

            if (offset > 0.0)
                return (scale * offset);
            /* else */ return scale;
        }
        else
        { // linear
            return (isSet(gain) && gain > 0.0) ? channel / gain : channel;
        }
    }

    // --------------------------------------------------------------------

}
